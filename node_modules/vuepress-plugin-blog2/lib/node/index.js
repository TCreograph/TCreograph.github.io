import{createPage as I,preparePageComponent as B,preparePageData as N,preparePagesComponents as V,preparePagesData as j,preparePagesRoutes as K}from"@vuepress/core";import{Logger as A,getPageExcerpt as F}from"vuepress-shared/node";import{watch as G}from"chokidar";import{isString as L,isFunction as U,removeLeadingSlash as D}from"@vuepress/shared";const r=new A("vuepress-plugin-blog2"),C=(t,v)=>{const f={};return Object.keys({"/":{},...v.options.locales}).forEach(g=>{f[g]=[]}),v.pages.filter(t).forEach(g=>{f[g.pathLocale].push(g)}),f},J=`
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
  if (__VUE_HMR_RUNTIME__.updateBlogCategory)
    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);
}

if (import.meta.hot)
  import.meta.hot.accept(({ categoryMap }) => {
    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);
  });

`,H=(t,v,f,g=!1)=>{const{category:w=[],slugify:E=a=>a.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase()}=v;return Promise.all(w.map(async({key:a,getter:m,sorter:_=()=>-1,path:i="/:key/",layout:y="Layout",frontmatter:e=()=>({}),itemPath:$="/:key/:name/",itemLayout:l="Layout",itemFrontmatter:b=()=>({})},p)=>{if(!L(a)||!a)return r.error(`Invalid 'key' option ${a} in 'category[${p}]'`),null;if(!U(m))return r.error(`Invalid 'getter' option in 'category[${p}]', it should be a function!`),null;t.env.isDebug&&r.info(`Generating ${a} category.
`);const h={},o=[],u=U($)?$:n=>($||"").replace(/:key/g,E(a)).replace(/:name/g,E(n));for(const n in f){if(i){const d=`${n}${D(i.replace(/:key/g,E(a)))}`,k=await I(t,{path:d,frontmatter:{...e(n),blog:{type:"category",key:a},layout:y}}),s=t.pages.findIndex(({path:M})=>M===d);s===-1?t.pages.push(k):t.pages[s].key!==k.key&&(t.pages.splice(s,1,k),g&&r.warn(`Overriding existed path ${d}`)),o.push(k.key),h[n]={path:k.path,map:{}}}else h[n]={path:"",map:{}};const{map:c}=h[n],R={};for(const d of f[n]){const k=m(d);for(const s of k){if(!c[s]){const M=u(s);if(M){const T=`${n}${D(M)}`,x=await I(t,{path:`${n}${D(M)}`,frontmatter:{...b(s,n),blog:{type:"category",name:s,key:a},layout:l}}),P=t.pages.findIndex(({path:S})=>S===T);P===-1?t.pages.push(x):t.pages[P].key!==x.key&&(t.pages.splice(P,1,x),g&&r.warn(`Overriding existed path ${T}`)),o.push(x.key),c[s]={path:x.path,keys:[]}}else c[s]={path:"",keys:[]};R[s]=[]}R[s].push(d)}}for(const d in R)c[d].keys=R[d].sort(_).map(({key:k})=>k);if(t.env.isDebug){let d=`Route ${n} in ${a} category:
`;for(const k in c){const{path:s,keys:M}=c[k];d+=`name: ${k}; ${s?`path: ${s}; `:""}items: ${M.length}
`}r.info(d)}}return{key:a,map:h,pageKeys:o}})).then(async a=>{const m={},_=[];return a.filter(i=>i!==null).forEach(({key:i,map:y,pageKeys:e})=>{m[i]=y,_.push(...e)}),await t.writeTemp("blog/category.js",`export const categoryMap = ${JSON.stringify(m)};
${t.env.isDev?J:""}
`),t.env.isDebug&&r.info("All categories generated."),_})},z=`
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
  if (__VUE_HMR_RUNTIME__.updateBlogType)
    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);
}

if (import.meta.hot)
  import.meta.hot.accept(({ typeMap }) => {
    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);
  });
`,O=(t,v,f,g=!1)=>{const{type:w=[],slugify:E=a=>a.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase()}=v;return Promise.all(w.map(async({key:a,sorter:m=()=>-1,filter:_=()=>!0,path:i="/:key/",layout:y="Layout",frontmatter:e=()=>({})},$)=>{if(!L(a)||!a)return r.error(`Invalid 'key' option ${a} in 'category[${$}]'`),null;const l={},b=[];t.env.isDebug&&r.info(`Generating ${a} type.
`);for(const p in f){const h=f[p].filter(_).sort(m).map(({key:o})=>o);if(i){const o=`${p}${D(E(i.replace(/:key/g,a)))}`,u=await I(t,{path:o,frontmatter:{...e(p),blog:{type:"type",key:a},layout:y}}),n=t.pages.findIndex(({path:c})=>c===o);n===-1?t.pages.push(u):t.pages[n].key!==u.key&&(t.pages.splice(n,1,u),g&&r.warn(`Overriding existed path ${o}`)),b.push(u.key),l[p]={path:u.path,keys:h},t.env.isDebug&&r.info(`Route ${p} in ${a} type: path: ${u.path}; items: ${h.length}
`)}else l[p]={path:"",keys:h},t.env.isDebug&&r.info(`Route ${p} in ${a} type: items: ${h.length}
`)}return{key:a,map:l,pageKeys:b}})).then(async a=>{const m={},_=[];return a.filter(i=>i!==null).forEach(({key:i,map:y,pageKeys:e})=>{m[i]=y,_.push(...e)}),await t.writeTemp("blog/type.js",`export const typeMap = ${JSON.stringify(m)};
${t.env.isDev?z:""}
`),t.env.isDebug&&r.info("All types generated."),_})},W=t=>v=>{const{getInfo:f=()=>({}),filter:g=e=>Boolean(e.filePathRelative)&&!e.frontmatter.home,metaScope:w="_blog",excerpt:E=!0,excerptSeparator:a="<!-- more -->",excerptLength:m=300,excerptFilter:_=g,isCustomElement:i=()=>!1}=t;let y=[];return v.env.isDebug&&r.info("Options:",t),{name:"vuepress-plugin-blog2",define:()=>({BLOG_META_SCOPE:w}),extendsPage:e=>{E&&_(e)&&(e.data.excerpt=F(v,e,{isCustomElement:i,excerptSeparator:a,excerptLength:m})),g(e)&&(e.routeMeta={...w===""?f(e):{[w]:f(e)},...e.routeMeta})},onInitialized:e=>{const $=C(g,e);return Promise.all([H(e,t,$,!0).then(l=>{y.push(...l)}),O(e,t,$,!0).then(l=>{y.push(...l)})]).then(()=>{e.env.isDebug&&r.info("temp file generated")})},onWatched:(e,$)=>{if("hotReload"in t?t.hotReload:e.env.isDebug){const l=G("pages/**/*.js",{cwd:e.dir.temp(),ignoreInitial:!0}),b=()=>{const p=[],h=C(g,e);return Promise.all([H(e,t,h).then(o=>{p.push(...o)}),O(e,t,h).then(o=>{p.push(...o)})]).then(async()=>{const o=y.filter(n=>!p.includes(n)),u=p.filter(n=>!y.includes(n));u.length&&(e.env.isDebug&&r.info(`New pages detected: ${u.toString()}`),await Promise.all(u.map(async n=>{await B(e,e.pages.find(({key:c})=>c===n)),await N(e,e.pages.find(({key:c})=>c===n))}))),o.length&&(e.env.isDebug&&r.info(`Removing following pages: ${o.toString()}`),o.forEach(n=>{e.pages.splice(e.pages.findIndex(({key:c})=>c===n),1)})),(o.length||u.length)&&(await V(e),await j(e),await K(e)),y=p,e.env.isDebug&&r.info("temp file updated")})};l.on("add",()=>{b()}),l.on("change",()=>{b()}),l.on("unlink",()=>{b()}),$.push(l)}}}};export{W as blogPlugin};
//# sourceMappingURL=index.js.map
