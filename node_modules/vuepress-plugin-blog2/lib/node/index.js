import{createPage as C,preparePageComponent as O,preparePageData as V,preparePagesComponents as j,preparePagesData as K,preparePagesRoutes as A}from"@vuepress/core";import{Logger as F,keys as G,getPageExcerpt as J}from"vuepress-shared/node";import{watch as z}from"chokidar";import{isString as U,isFunction as L,removeLeadingSlash as D}from"@vuepress/shared";import{colors as l}from"@vuepress/utils";const o=new F("vuepress-plugin-blog2"),H=(e,M)=>{const u={};return G({"/":{},...M.options.locales}).forEach(f=>{u[f]=[]}),M.pages.filter(e).forEach(f=>{u[f.pathLocale].push(f)}),u},W=`
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
  if (__VUE_HMR_RUNTIME__.updateBlogCategory)
    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);
}

if (import.meta.hot)
  import.meta.hot.accept(({ categoryMap }) => {
    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);
  });

`,S=(e,M,u,f=!1)=>{const{category:P=[],slugify:E=a=>a.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase()}=M;return Promise.all(P.map(async({key:a,getter:h,sorter:k=()=>-1,path:i="/:key/",layout:b="Layout",frontmatter:y=()=>({}),itemPath:t="/:key/:name/",itemLayout:v="Layout",itemFrontmatter:m=()=>({})},c)=>{if(!U(a)||!a)return o.error(`Invalid ${l.magenta("key")} option ${l.cyan(a)} in ${l.cyan(`category[${c}]`)}`),null;if(!L(h))return o.error(`Invalid ${l.magenta("getter")} option in "${l.cyan(`category[${c}]`)}", it should be a function!`),null;e.env.isDebug&&o.info(`Generating ${l.cyan(a)} category.
`);const s={},d=[],r=L(t)?t:n=>(t||"").replace(/:key/g,E(a)).replace(/:name/g,E(n));for(const n in u){if(i){const $=`${n}${D(i.replace(/:key/g,E(a)))}`,_=await C(e,{path:$,frontmatter:{...y(n),blog:{type:"category",key:a},layout:b}}),g=e.pages.findIndex(({path:R})=>R===$);g===-1?e.pages.push(_):e.pages[g].key!==_.key&&(e.pages.splice(g,1,_),f&&o.warn(`Overriding existed path ${l.cyan($)}`)),d.push(_.key),s[n]={path:_.path,map:{}}}else s[n]={path:"",map:{}};const{map:p}=s[n],w={};for(const $ of u[n]){const _=h($);for(const g of _){if(!p[g]){const R=r(g);if(R){const T=`${n}${D(R)}`,x=await C(e,{path:`${n}${D(R)}`,frontmatter:{...m(g,n),blog:{type:"category",name:g,key:a},layout:v}}),I=e.pages.findIndex(({path:N})=>N===T);I===-1?e.pages.push(x):e.pages[I].key!==x.key&&(e.pages.splice(I,1,x),f&&o.warn(`Overriding existed path ${T}`)),d.push(x.key),p[g]={path:x.path,keys:[]}}else p[g]={path:"",keys:[]};w[g]=[]}w[g].push($)}}for(const $ in w)p[$].keys=w[$].sort(k).map(({key:_})=>_);if(e.env.isDebug){let $=`Route ${n} in ${a} category:
`;for(const _ in p){const{path:g,keys:R}=p[_];$+=`name: ${_}; ${g?`path: ${g}; `:""}items: ${R.length}
`}o.info($)}}return{key:a,map:s,pageKeys:d}})).then(async a=>{const h={},k=[];return a.filter(i=>i!==null).forEach(({key:i,map:b,pageKeys:y})=>{h[i]=b,k.push(...y)}),await e.writeTemp("blog/category.js",`export const categoryMap = ${JSON.stringify(h)};
${e.env.isDev?W:""}
`),e.env.isDebug&&o.info("All categories generated."),k})},q=`
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
  if (__VUE_HMR_RUNTIME__.updateBlogType)
    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);
}

if (import.meta.hot)
  import.meta.hot.accept(({ typeMap }) => {
    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);
  });
`,B=(e,M,u,f=!1)=>{const{type:P=[],slugify:E=a=>a.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase()}=M;return Promise.all(P.map(async({key:a,sorter:h=()=>-1,filter:k=()=>!0,path:i="/:key/",layout:b="Layout",frontmatter:y=()=>({})},t)=>{if(!U(a)||!a)return o.error(`Invalid ${l.magenta("key")} option ${l.cyan(a)} in ${l.cyan(`type[${t}]`)}`),null;const v={},m=[];e.env.isDebug&&o.info(`Generating ${l.cyan(a)} type.
`);for(const c in u){const s=u[c].filter(k).sort(h).map(({key:d})=>d);if(i){const d=`${c}${D(E(i.replace(/:key/g,a)))}`,r=await C(e,{path:d,frontmatter:{...y(c),blog:{type:"type",key:a},layout:b}}),n=e.pages.findIndex(({path:p})=>p===d);n===-1?e.pages.push(r):e.pages[n].key!==r.key&&(e.pages.splice(n,1,r),f&&o.warn(`Overriding existed path ${l.cyan(d)}`)),m.push(r.key),v[c]={path:r.path,keys:s},e.env.isDebug&&o.info(`Route ${c} in ${a} type: path: ${r.path}; items: ${s.length}
`)}else v[c]={path:"",keys:s},e.env.isDebug&&o.info(`Route ${c} in ${a} type: items: ${s.length}
`)}return{key:a,map:v,pageKeys:m}})).then(async a=>{const h={},k=[];return a.filter(i=>i!==null).forEach(({key:i,map:b,pageKeys:y})=>{h[i]=b,k.push(...y)}),await e.writeTemp("blog/type.js",`export const typeMap = ${JSON.stringify(h)};
${e.env.isDev?q:""}
`),e.env.isDebug&&o.info("All types generated."),k})},Q=e=>{"customElement"in e&&(o.warn(`${l.magenta("customElement")} is deprecated, please use ${l.magenta("isCustomElement")}.`),e.isCustomElement=e.customElement)},X=(e,M=!0)=>u=>{M&&Q(e);const{getInfo:f=()=>({}),filter:P=t=>Boolean(t.filePathRelative)&&!t.frontmatter.home,metaScope:E="_blog",excerpt:a=!0,excerptSeparator:h="<!-- more -->",excerptLength:k=300,excerptFilter:i=P,isCustomElement:b=()=>!1}=e;let y=[];return u.env.isDebug&&o.info("Options:",e),{name:"vuepress-plugin-blog2",define:()=>({BLOG_META_SCOPE:E}),extendsPage:t=>{a&&i(t)&&(t.data.excerpt=J(u,t,{isCustomElement:b,excerptSeparator:h,excerptLength:k})),P(t)&&(t.routeMeta={...E===""?f(t):{[E]:f(t)},...t.routeMeta})},onInitialized:t=>{const v=H(P,t);return Promise.all([S(t,e,v,!0).then(m=>{y.push(...m)}),B(t,e,v,!0).then(m=>{y.push(...m)})]).then(()=>{t.env.isDebug&&o.info("temp file generated")})},onWatched:(t,v)=>{if("hotReload"in e?e.hotReload:t.env.isDebug){const m=z("pages/**/*.js",{cwd:t.dir.temp(),ignoreInitial:!0}),c=()=>{const s=[],d=H(P,t);return Promise.all([S(t,e,d).then(r=>{s.push(...r)}),B(t,e,d).then(r=>{s.push(...r)})]).then(async()=>{const r=y.filter(p=>!s.includes(p)),n=s.filter(p=>!y.includes(p));n.length&&(t.env.isDebug&&o.info(`New pages detected: ${n.toString()}`),await Promise.all(n.map(async p=>{await O(t,t.pages.find(({key:w})=>w===p)),await V(t,t.pages.find(({key:w})=>w===p))}))),r.length&&(t.env.isDebug&&o.info(`Removing following pages: ${r.toString()}`),r.forEach(p=>{t.pages.splice(t.pages.findIndex(({key:w})=>w===p),1)})),(r.length||n.length)&&(await j(t),await K(t),await A(t)),y=s,t.env.isDebug&&o.info("temp file updated")})};m.on("add",()=>{c()}),m.on("change",()=>{c()}),m.on("unlink",()=>{c()}),v.push(m)}}}};export{X as blogPlugin};
//# sourceMappingURL=index.js.map
